[toc]

# 指令系统

## 指令格式

### 指令的基本格式

|操作码字段|地址码字段|
|-|-|

+ 操作码：指出指令中该指令应该执行什么性质的操作和具有何种功能
+ 地址码：指出被操作的信息的地址（参加运算的操作数所在的地址，运算结果的保存地址，程序的转移地址，被调用的子程序的入口地址）
+ 指令的长度：一条指令中所包含的二进制的位数

单字长指令：指令长度等于一个机器字长的指令
半字长指令：指令长度等于半个机器字长的指令
双字长指令：指令长度等于两个机器字长的指令

#### 零地址指令

|OP|
|-|
只需要给出操作码 OP，没有显式地址：

1. 不需要操作数的指令：空操作指令，停机指令，关中断指令
2. 林地址的运算类指令：堆栈计算机

#### 一地址指令

|OP|$A_1$|
|-|-|

1. 只有目的操作数的单操作数指令。按$A_1$地址读取操作数，进行 OP 操作，结果存回原地址
2. 隐含约定目的地址的双操作数指令，按指令地址$A_1$可读取源操作数，指令可隐含约定另一个操作数由 ACC（累加器）提供

#### 二地址指令

|OP|$A_1$|$A_2$|
|-|-|-|
$（A_1）OP（A_2）→A_1$

分别给出目标操作数和源操作数的地址，目标操作数的地址用于保存本次运算的运算结果

#### 三地址指令

|OP|$A_1$|$A_2$|$A_3$（结果）|
|-|-|-|-|

#### 四地址指令

|OP|$A_1$|$A_2$|$A_3$（结果）|$A_4$（下址）|
|-|-|-|-|-|

### 定长操作码指令格式

在指令字的最高位部分分配固定的若干位（定长）表示操作码

+ 简化计算机硬件设计，提高指令译码和识别速度

### 扩展操作码指令格式

+ 不允许短码是长码的前缀
+ 各指令的操作码一定不能重复

## 指令寻址方式

### 指令寻址和数据寻址

#### 指令寻址

1. 顺序寻址
   通过程序计数器（PC）加 1，自动形成下一条指令的地址
2. 跳跃寻址
   通过转移类指令实现，下一条指令的地址码不由程序状态计数器给出，而是由本条指令给出下条指令地址的计算方式，**跳跃的结果是修改 PC 值，下一条指令仍然通过 PC 给出**

#### 数据寻址

|操作码|寻址特征|形式地址 A|
|-|-|-|

### 常见的数据寻址方式

#### 隐含寻址

在指令中隐含操作数的地址，如规定 ACC 作为第二操作数的地址，指令明显指出仅仅是第一操作数的地址

+ 优点：有利于缩短指令字长
+ 缺点：需增加存储操作数或隐含地址的硬件

#### 立即数寻址

地址字段指出的是操作数本身

+ 优点：指令在执行阶段不访问主存，指令执行时间短
+ 缺点：地址字段的位数限制了立即数的范围

#### 直接寻址

指令字的形式地址 A 是操作数的真实地址 EA，即 EA=A

+ 优点：简单，指令执行阶段仅访问一次主存，不需要专门计算操作数的地址
+ 确定啊：A 的位数决定了指令操作书的寻址范围，操作数的地址不易修改

#### 间接寻址

指令地址字段的形式地址不是操作数的真正地址，而是操作数有效地址所在的存储单元的地址，即**操作数地址的地址**，EA=（A）
间接寻址可以是一次间接寻址，也可以是多次间接寻址

+ 优点： 可扩大寻址范围
+ 缺点：指令再执行阶段要多次访存

#### 寄存器寻址

指令字中直接给出操作数所在的寄存器编号，$EA=R_i$,操作数在$R_i$所指的寄存器内

#### 寄存器间接寻址

寄存器$R_i$中给出的不是操作数，而是操作数所在主存单元的地址，$EA=（R_i）$

+ 优点：比一般间接寻址相比速度快
+ 缺点：指令执行阶段需要访问主存

#### 相对寻址

把程序计数器（PC）的内容加上指令格式中的形式地址 A 形成操作数的有效地址
，$EA=（PC）+A$

+ 优点：操作数的地址不是固定的，随 PC 值的变化而变化，便于程序浮动，广泛应用于转移指令

#### 基址寻址

将 CPU 中基址寄存器 BR 的内容加上指令格式的形式地址 A 形成操作数的有效地址，EA=（BR）+A，基址寄存器既可采用专用寄存器，又可采用通用寄存器

+ 优点： 可扩大寻址范围，有利于多道程序设计
+ 缺点：偏移量（形式地址A）的位数较短

#### 变址寻址

有效地址 EA 等于指令字中形式地址 A 与变址寄存器 IX 的内容之和，$EA=（IX）+A$,其中 IX为变址寄存器（专用），也可用通用寄存器作为变址寄存器

+ 优点：可扩大寻址范围

#### 堆栈寻址

#### 总结

|寻址方式|有效地址|访存次数|
|-|-|-|
|隐含寻址|程序指定|0|
|立即寻址|A 即使操作数|0|
|直接寻址|EA=A|1|
|一次间接寻址|EA=（A）|2|
|寄存器寻址|EA=R_i|0|
|寄存器间接一次寻址|EA=（R_i）|1|
|相对寻址|EA=（PC）+A|1|
|基址寻址|EA=（BR）+A|1|
|变址寻址|EA=（IX）+A|1|

## CISC和 RISC 的基本概念

### 复杂指令系统计算机（CISC）

1. 指令系统复杂庞大，指令数目一般为 200 条以上
2. 指令的长度不固定，指令格式多，寻址方式多
3. 可以访存的指令不受限制
4. 各种指令使用频度相差很大
5. 各种指令执行时间相差很大，大多数指令需在多个时钟周期内才能完成
6. 控制器大多采用微程序控制
7. 难以用优化编译生成高效的目标代码

### 精简指令系统计算机（RISC）

1. 选取使用频率最高的一些简单指令，复杂指令有简单指令的组合实现
2. 指令长度固定，指令格式种类少，寻址方式少
3. 只有 Load/Store指令访存，其余指令都在寄存器之间进行
4. CPU 中通用寄存器的数量多
5. 采用指令流水技术，大部分指令在一个时钟周期内完成
6. 以硬布线控制为主，不用或少用微程序控制
7. 重视编译优化工作，减少程序执行时间

### CISC 和 RISC 的比较

||CISC|RISC|
|-|-|-|
|指令系统|复杂，庞大|简单、精简|
|指令数目|一般大于 200 条|一般小于 100 条|
|指令字长|不固定|定长|
|可访存指令|不加限制|只有 Load/Store 指令|
|各种指令执行时间|相差较大|绝大多数在一个周期内完成|
|各种指令使用频度|相差很大|都比较经常使用|
|通用寄存器数量|较少|多|
|目标代码|难以用优化编译生成高效的目标代码程序|采用优化的编译程序，生成的代码较为高效|
|控制方式|微程序控制为主|组合逻辑控制为主|
|指令流水线|通过一定方式实现|必须实现|