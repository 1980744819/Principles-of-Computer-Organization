# 数据的表示和运算

## 数制与编码

### 校验码

#### 奇偶校验码

+ 奇校验码
  整个校验码中"1"的个数为奇数
+ 偶校验码
  整个校验码中"1"的个数为偶数

## 定点数的表示和运算

### 定点数的运算

#### 定点数的移位运算

##### 算数移位

||码制|添补代码|
|-|-|-|
|正数|原码、补码、反码|0|
|负数|原码|0|
||补码|左移添 0|
||补码|右移添 1|
||反码|1|

##### 逻辑移位

#### 原码定点数的加减法运算

+ 加法规则
  **先判断符号位**，若相同，则绝对值相加，结果符号位不变；若不同，则做减法，绝对值大的数减去绝对值较小的数，结果符号位与绝对值较大的数相同
+ 减法规则
  两个原码表示的数相减，首先将被减数**符号取反**，然后将被减数与符号取反后的减数按原码加法进行运算

#### 补码定点数加减法运算

1. 参与运算的两个操作数均用补码表示
2. 按二进制运算规则运算，逢二进一
3. 符号位与数值位按同样规则一起参与运算，符号位产生的进位要丢掉，结果的符号位由运算得出
4. 补码加减法运算按照下面的公式进行
   $[A+B]_补=[A]_补+[B]_补(mod\ M)$
   $[A-B]_补=[A]_补+[-B]_补(mod\ M)$
5. 补码的运算结果也为补码

#### 符号扩展（位数转换）

+ 正数
  附加位都用0进行填充
+ 负数
  + 补码：附加位用1（整数）或0（小数）进行填充
  + 反码：附加位用1进行填充

#### 溢出概念和判别方法

##### 采用一位符号位

参与操作的两个数符号相同，结果又与原操作数符号不同，表示结果溢出

#### 采用双符号位

1. $S_{s1}S_{s2}=00$:结果为正，无溢出
2. $S_{s1}S_{s2}=01$：正溢出
3. $S_{s1}S_{s2}=10$：负溢出
4. $S_{s1}S_{s2}=11$：结果为负，无溢出

#### 定点数的乘法运算

##### 原码一位乘法

设$[X]_原=x_sx_1x_1\cdots x_n$,$[Y]_原=y_sy_1y_1\cdots y_n$,运算规则如下：

1. 被乘数和乘数取绝对值参与运算，符号位为两个数的符号位的异或运算
2. 部分积的长度同被乘数，取n+1位，以便存放乘法过程中绝对值大于等一1的值，初始值为0
3. 从乘数部分最低位开始判断，若等于1，部分积加上被乘数，右移一位；若等于0，则部分积加上0，右移一位
4. 重复第3步，判断n次


##### 补码一位乘法（Booth算法）

1. 符号位参与运算
2. 被乘数一般取双符号位参与运算，部分积取双符号位，初始值为0，乘数可去单符号位
3. 乘数末尾增设附加位$y_{n+1}$，初始值为0
4. 根据$(y_n,y_{n+1})$的取值确定操作
5. 移位按照右移规则进行
6. 按照上述算法进行n+1步操作，但最后一步不再移位

|$y_n$|$y_{n+1}$|操作|
|-|-|-|
|0|0|部分积右移一位|
|0|1|部分积加$[X]_补$，右移一位|
|1|0|部分积加$[-X]_补$，右移一位|
|1|1|部分积右移一位|

#### 定点数的出发运算

##### 原码除法运算（不恢复余数法）

##### 补码除法运算（加减交替法）

## 浮点数的表示和运算

## 算术逻辑单元